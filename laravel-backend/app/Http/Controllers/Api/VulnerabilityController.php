<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Vulnerability;
use App\Models\VulnerabilityAsset;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;

class VulnerabilityController extends Controller
{
    public function getStats(Request $request): JsonResponse
    {
        try {
            $companyId = $request->user()->company_id ?? 1;
            
            $stats = [
                'critical' => Vulnerability::whereHas('asset', function($q) use ($companyId) {
                    $q->where('company_id', $companyId);
                })->where('severity', 'critical')->where('status', '!=', 'resolved')->count(),
                
                'high' => Vulnerability::whereHas('asset', function($q) use ($companyId) {
                    $q->where('company_id', $companyId);
                })->where('severity', 'high')->where('status', '!=', 'resolved')->count(),
                
                'medium' => Vulnerability::whereHas('asset', function($q) use ($companyId) {
                    $q->where('company_id', $companyId);
                })->where('severity', 'medium')->where('status', '!=', 'resolved')->count(),
                
                'low' => Vulnerability::whereHas('asset', function($q) use ($companyId) {
                    $q->where('company_id', $companyId);
                })->where('severity', 'low')->where('status', '!=', 'resolved')->count(),
                
                'resolved' => Vulnerability::whereHas('asset', function($q) use ($companyId) {
                    $q->where('company_id', $companyId);
                })->where('status', 'resolved')->count(),
                
                'assetsScanned' => VulnerabilityAsset::where('company_id', $companyId)->count(),
                'lastScanTime' => now()->toISOString(),
                'avgResolutionTime' => 4.2,
                'openTrend' => -12
            ];

            $stats['total'] = $stats['critical'] + $stats['high'] + $stats['medium'] + $stats['low'];

            return response()->json($stats);
        } catch (\Exception $e) {
            Log::error('Failed to fetch vulnerability stats', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to fetch vulnerability stats'], 500);
        }
    }

    public function getAssets(Request $request): JsonResponse
    {
        try {
            $companyId = $request->user()->company_id ?? 1;
            
            $assets = VulnerabilityAsset::where('company_id', $companyId)
                ->withCount(['vulnerabilities' => function($q) {
                    $q->where('status', '!=', 'resolved');
                }])
                ->get()
                ->map(function($asset) {
                    return [
                        'id' => (string)$asset->id,
                        'name' => $asset->name,
                        'type' => $asset->type,
                        'target' => $asset->target,
                        'description' => $asset->description,
                        'lastScan' => $asset->last_scan_at?->toISOString(),
                        'status' => $asset->status,
                        'vulnerabilityCount' => $asset->vulnerabilities_count ?? 0,
                        'riskScore' => $asset->risk_score ?? 0,
                        'tags' => $asset->tags ?? []
                    ];
                });

            return response()->json($assets);
        } catch (\Exception $e) {
            Log::error('Failed to fetch assets', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to fetch assets'], 500);
        }
    }

    public function createAsset(Request $request): JsonResponse
    {
        try {
            $validator = Validator::make($request->all(), [
                'name' => 'required|string|max:255',
                'type' => 'required|in:url,domain,ip,file_system',
                'target' => 'required|string|max:500',
                'description' => 'nullable|string|max:1000',
                'tags' => 'nullable|array'
            ]);

            if ($validator->fails()) {
                return response()->json(['errors' => $validator->errors()], 422);
            }

            $asset = VulnerabilityAsset::create([
                'company_id' => $request->user()->company_id ?? 1,
                'name' => $request->name,
                'type' => $request->type,
                'target' => $request->target,
                'description' => $request->description,
                'status' => 'active',
                'risk_score' => 0,
                'tags' => $request->tags ?? []
            ]);

            return response()->json([
                'id' => (string)$asset->id,
                'name' => $asset->name,
                'type' => $asset->type,
                'target' => $asset->target,
                'description' => $asset->description,
                'lastScan' => null,
                'status' => $asset->status,
                'vulnerabilityCount' => 0,
                'riskScore' => $asset->risk_score,
                'tags' => $asset->tags ?? []
            ], 201);
        } catch (\Exception $e) {
            Log::error('Failed to create asset', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to create asset'], 500);
        }
    }

    public function getVulnerabilities(Request $request): JsonResponse
    {
        try {
            $companyId = $request->user()->company_id ?? 1;
            
            $vulnerabilities = Vulnerability::whereHas('asset', function($q) use ($companyId) {
                $q->where('company_id', $companyId);
            })
            ->with(['asset', 'assignedUser'])
            ->when($request->severity, function($q, $severity) {
                $q->where('severity', $severity);
            })
            ->when($request->status, function($q, $status) {
                $q->where('status', $status);
            })
            ->latest('discovered_at')
            ->get()
            ->map(function($vuln) {
                return [
                    'id' => (string)$vuln->id,
                    'title' => $vuln->title,
                    'severity' => $vuln->severity,
                    'assetId' => (string)$vuln->vulnerability_asset_id,
                    'assetName' => $vuln->asset->name,
                    'cvssScore' => $vuln->cvss_score,
                    'cveReference' => $vuln->cve_reference,
                    'exploitability' => $vuln->exploitability,
                    'status' => $vuln->status,
                    'discovered' => $vuln->discovered_at->toISOString(),
                    'description' => $vuln->description,
                    'remediation' => $vuln->remediation,
                    'affectedComponent' => $vuln->affected_component,
                    'assignedTo' => $vuln->assignedUser?->name,
                    'impact' => [
                        'availability' => $vuln->impact_availability,
                        'confidentiality' => $vuln->impact_confidentiality,
                        'integrity' => $vuln->impact_integrity
                    ]
                ];
            });

            return response()->json($vulnerabilities);
        } catch (\Exception $e) {
            Log::error('Failed to fetch vulnerabilities', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to fetch vulnerabilities'], 500);
        }
    }

    public function updateVulnerability(Request $request, $id): JsonResponse
    {
        try {
            $companyId = $request->user()->company_id ?? 1;
            
            $vulnerability = Vulnerability::whereHas('asset', function($q) use ($companyId) {
                $q->where('company_id', $companyId);
            })->findOrFail($id);

            $validator = Validator::make($request->all(), [
                'status' => 'sometimes|in:open,in_progress,resolved,ignored',
                'assigned_to' => 'sometimes|nullable|exists:users,id',
                'notes' => 'sometimes|nullable|string'
            ]);

            if ($validator->fails()) {
                return response()->json(['errors' => $validator->errors()], 422);
            }

            $updateData = $request->only(['status', 'assigned_to', 'notes']);
            
            if ($request->status === 'resolved') {
                $updateData['resolved_at'] = now();
            }

            $vulnerability->update($updateData);

            return response()->json([
                'id' => (string)$vulnerability->id,
                'status' => $vulnerability->status,
                'updatedAt' => $vulnerability->updated_at->toISOString()
            ]);
        } catch (\Exception $e) {
            Log::error('Failed to update vulnerability', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to update vulnerability'], 500);
        }
    }

    public function startScan(Request $request): JsonResponse
    {
        try {
            $validator = Validator::make($request->all(), [
                'assetIds' => 'required|array',
                'scanType' => 'required|in:basic,standard,deep',
                'scheduled' => 'boolean',
                'frequency' => 'nullable|in:daily,weekly,monthly'
            ]);

            if ($validator->fails()) {
                return response()->json(['errors' => $validator->errors()], 422);
            }

            $scanJob = [
                'id' => uniqid(),
                'name' => ucfirst($request->scanType) . ' Security Scan',
                'status' => 'running',
                'progress' => 0,
                'startTime' => now()->toISOString(),
                'assetsScanned' => count($request->assetIds),
                'vulnerabilitiesFound' => 0,
                'scanType' => $request->scanType
            ];

            return response()->json($scanJob, 202);
        } catch (\Exception $e) {
            Log::error('Failed to start scan', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to start scan'], 500);
        }
    }

    public function getScanHistory(Request $request): JsonResponse
    {
        try {
            $scans = [
                [
                    'id' => 'scan-1',
                    'name' => 'Weekly Security Scan',
                    'status' => 'completed',
                    'progress' => 100,
                    'startTime' => now()->subHours(2)->toISOString(),
                    'endTime' => now()->subHour()->toISOString(),
                    'assetsScanned' => 15,
                    'vulnerabilitiesFound' => 12,
                    'scanType' => 'Standard'
                ]
            ];

            return response()->json($scans);
        } catch (\Exception $e) {
            Log::error('Failed to fetch scan history', ['error' => $e->getMessage()]);
            return response()->json(['error' => 'Failed to fetch scan history'], 500);
        }
    }
}